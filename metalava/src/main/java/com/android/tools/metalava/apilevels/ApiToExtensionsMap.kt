/*
 * Copyright (C) 2022 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.android.tools.metalava.apilevels

/**
 * A filter of classes, fields and methods that are allowed in and extension SDK, and for each item,
 * what extension SDK it first appeared in. Also, a mapping between SDK name and numerical ID.
 *
 * Internally, the filters are represented as a tree, where each node in the tree matches a part of
 * a package, class or member name. For example, given the patterns
 *
 * ```
 * com.example.Foo -> [A] com.example.Foo#someMethod -> [B] com.example.Bar -> [A, C]
 * ```
 *
 * (anything prefixed with com.example.Foo is allowed and part of the A extension, except for
 * com.example.Foo#someMethod which is part of B; anything prefixed with com.example.Bar is part of
 * both A and C), the internal tree looks like
 *
 * ```
 * root -> null com -> null example -> null Foo -> [A] someMethod -> [B] Bar -> [A, C]
 * ```
 */
class ApiToExtensionsMap
internal constructor(
    private val availableSdkExtensions: AvailableSdkExtensions,
    internal val root: Node,
) {
    fun isEmpty(): Boolean = root.children.isEmpty() && root.extensions.isEmpty()

    fun getExtensions(clazz: ApiClass): List<String> = getExtensions(clazz.name.toDotNotation())

    fun getExtensions(clazz: ApiClass, member: ApiElement): List<String> =
        getExtensions(clazz.name.toDotNotation() + "#" + member.name.toDotNotation())

    fun getExtensions(what: String): List<String> {
        // Special case: getExtensionVersion is not part of an extension
        val sdkExtensions = "android.os.ext.SdkExtensions"
        if (what == sdkExtensions || what == "$sdkExtensions#getExtensionVersion") {
            return listOf()
        }

        val parts = what.splitIntoBreadcrumbs()

        var lastSeenExtensions = root.extensions
        var node = root.children.findNode(parts[0]) ?: return lastSeenExtensions
        if (node.extensions.isNotEmpty()) {
            lastSeenExtensions = node.extensions
        }

        for (part in parts.stream().skip(1)) {
            node = node.children.findNode(part) ?: break
            if (node.extensions.isNotEmpty()) {
                lastSeenExtensions = node.extensions
            }
        }
        return lastSeenExtensions
    }

    /**
     * Construct a `sdks` attribute value
     *
     * `sdks` is an XML attribute on class, method and fields in the XML generated by
     * ARG_GENERATE_API_LEVELS. It expresses in what SDKs an API exist, and in which version of each
     * SDK it was first introduced; `sdks` replaces the `since` attribute.
     *
     * The format of `sdks` is
     *
     * ```
     * sdks="ext:version[,ext:version[,...]]
     * ```
     *
     * where <ext> is the numerical ID of the SDK, and <version> is the version in which the API was
     * introduced.
     *
     * The returned string is guaranteed to be one of
     * - list of (extensions,finalized_version) pairs + ANDROID_SDK:finalized_dessert
     * - list of (extensions,finalized_version) pairs
     * - ANDROID_SDK:finalized_dessert
     * - ANDROID_SDK:next_dessert_int (for symbols not finalized anywhere)
     *
     * See go/mainline-sdk-api-versions-xml for more information.
     *
     * @param androidSince Android dessert version in which this symbol was finalized, or
     *   notFinalizedValue if this symbol has not been finalized in an Android dessert
     * @param notFinalizedValue value used together with the Android SDK ID to indicate that this
     *   symbol has not been finalized at all
     * @param shortExtensionNames short names of the SDK extensions in which this symbol has been
     *   finalized; may be non-empty even if extensionsSince is `null`.
     * @param extensionsSince the version of the SDK extensions in which this API was initially
     *   introduced (same value for all SDK extensions), or `null` if this symbol has not been
     *   finalized in any SDK extension (regardless of the [shortExtensionNames] argument)
     * @return an `sdks` value suitable for including verbatim in XML
     */
    fun calculateSdksAttr(
        androidSince: ApiVersion,
        notFinalizedValue: ApiVersion,
        shortExtensionNames: List<String>,
        extensionsSince: ExtVersion?,
    ): String {
        // Special case: symbol not finalized anywhere -> "ANDROID_SDK:next_dessert_int"
        if (androidSince == notFinalizedValue && extensionsSince == null) {
            return "$ANDROID_PLATFORM_SDK_ID:$notFinalizedValue"
        }

        val versions = mutableSetOf<String>()
        // Only include SDK extensions if the symbol has been finalized in at least one extension.
        if (extensionsSince != null) {
            for (shortExtensionName in shortExtensionNames) {
                val sdkExtension = availableSdkExtensions.retrieveSdkExtension(shortExtensionName)
                // Only add the extension version in which a symbol was added for those SDK
                // extensions that supersede the Android SDK version.
                if (sdkExtension.supersedesAndroidSdkVersion(androidSince)) {
                    versions.add("${sdkExtension.id}:$extensionsSince")
                }
            }
        }

        // Only include the Android SDK in `sdks` if
        // - the symbol has been finalized in an Android dessert, and
        // - the symbol has been finalized in at least one SDK extension
        if (androidSince != notFinalizedValue && versions.isNotEmpty()) {
            versions.add("$ANDROID_PLATFORM_SDK_ID:$androidSince")
        }
        return versions.joinToString(",")
    }

    companion object {
        // Hard-coded ID for the Android platform SDK. Used identically as the extension SDK IDs
        // to express when an API first appeared in an SDK.
        const val ANDROID_PLATFORM_SDK_ID = 0
    }
}

internal fun Set<Node>.findNode(breadcrumb: String): Node? = find { it.breadcrumb == breadcrumb }

private fun String.toDotNotation(): String = split('(')[0].replace('/', '.')

internal class Node(val breadcrumb: String) {
    var extensions: List<String> = emptyList()
    val children: MutableSet<Node> = mutableSetOf()
}

/**
 * Regular expression used to split an internal symbol name into separate breadcrumbs, i.e. values
 * that will be used in [Node.breadcrumb].
 */
private val REGEX_DELIMITERS = Regex("[.#$]")

/**
 * Split the string into breadcrumbs, i.e. values that will be used in [Node.breadcrumb].
 *
 * e.g. if this is com.example.Foo$Inner#method(I)I then this will split it into:
 * * "com"
 * * "example"
 * * "Foo"
 * * "Inner"
 * * "method(I)I"
 */
internal fun String.splitIntoBreadcrumbs() = split(REGEX_DELIMITERS)
